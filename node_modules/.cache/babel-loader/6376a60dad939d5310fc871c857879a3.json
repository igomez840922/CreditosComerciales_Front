{"ast":null,"code":"import axios from \"axios\";\nimport TokenService from \"./TokenService\";\nimport * as url from \"../helpers/url_helper\";\nimport qs from 'qs';\nimport http from \"http\";\nimport https from \"https\";\nconst userId = \"ARICO1\";\nconst client_id = '6cbk7drlvbc88vdgvgo1tg1r3o'; //'rrcmi5fefq56q4bc9pri0mfa0';//\n\nconst client_secret = 'b9vti5n8pbn1cn2gr35vlgq8s3uq7mm1j2d79ih0u1jjb4hkd3m'; //'k7f89803rmgu8n93ppr3e2honuguo064ga8co4oqgml8k0tdrbp';//\n\nconst httpAgent = new http.Agent({\n  keepAlive: true\n});\nconst httpsAgent = new https.Agent({\n  keepAlive: true\n}); //apply base url for axios\n\nconst API_URL = \"\";\nconst axiosApi = axios.create({\n  baseURL: API_URL,\n  httpAgent,\n  httpsAgent,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    \"userId\": userId\n  }\n});\n/*\r\naxiosApi.interceptors.response.use(\r\n  response => response,\r\n  error => Promise.reject(error)\r\n)\r\n*/\n\naxiosApi.interceptors.request.use(config => {\n  const token = TokenService.getLocalAccessToken();\n\n  if (token) {\n    config.headers[\"Authorization\"] = 'Bearer ' + token.access_token; //config.headers[\"x-access-token\"] = token; // for Node.js Express back-end\n  } // console.log('config: ',config);\n\n\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\naxiosApi.interceptors.response.use(res => {\n  return res;\n}, async err => {\n  //return Promise.reject(err);\n  console.log('err: ', err);\n  const originalConfig = err.config; // console.log('originalConfig: ',originalConfig);\n\n  if (originalConfig.url === url.URL_CORE_TOKENGEN) {\n    return Promise.reject(err);\n  }\n\n  var token = TokenService.getLocalAccessToken(); //si existe Token chequear la validez de tiempo\n\n  if (token) {\n    //calculamos que el expiration time est√© correcto\n    var elapsed = new Date().getTime() - token.tokenexpiration;\n\n    if (elapsed < 0) {\n      return Promise.reject(err);\n    }\n  }\n\n  TokenService.removeLocalAccessToken();\n  originalConfig._retry = true;\n\n  try {\n    const data = qs.stringify({\n      grant_type: 'client_credentials'\n    });\n    const headers = {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Authorization': \"Basic \" + btoa(client_id + \":\" + client_secret)\n    };\n    var rs = await axiosApi.post(url.URL_CORE_TOKENGEN, data, {\n      headers: headers\n    });\n    var responsetokenJson = rs.data;\n    var tokenexpiration = new Date();\n    tokenexpiration.setSeconds(new Date().getSeconds() + parseInt(responsetokenJson.expires_in));\n    responsetokenJson.tokenexpiration = tokenexpiration.getTime();\n    TokenService.updateLocalAccessToken(responsetokenJson);\n    originalConfig.headers[\"Authorization\"] = 'Bearer ' + responsetokenJson.access_token;\n    return axiosApi(originalConfig);\n  } catch (_error) {\n    return Promise.reject(_error);\n  }\n  /*\r\n  //originalConfig.url !== \"/auth/signin\" &&\r\n  if (err.response) {\r\n    // Access Token was expired\r\n    if (err.response.status === 401 && !originalConfig._retry) {\r\n      originalConfig._retry = true;\r\n        try {\r\n          const data = qs.stringify({\r\n          grant_type: 'client_credentials'\r\n        });\r\n        const headers = {\r\n          'Content-Type': 'application/x-www-form-urlencoded',\r\n          'Authorization': \"Basic \" + btoa(client_id + \":\" + client_secret)\r\n        };\r\n          const rs = await axiosApi.post(url_TokenGeneration,\r\n          data,headers\r\n        );\r\n          console.log(rs.data);\r\n        TokenService.updateLocalAccessToken(rs.data);\r\n          //const { accessToken } = rs.data;\r\n        return axiosApi(originalConfig);\r\n        }\r\n      catch (_error) {\r\n        return Promise.reject(_error);\r\n      }\r\n    }\r\n  }\r\n    return Promise.reject(err);\r\n    */\n\n});\nexport default class ApiServiceCore {\n  async get(url, config = {}) {\n    return await axiosApi.get(url, { ...config\n    }).then(response => response.data);\n  }\n\n  async post(url, data, config = {}) {\n    return axiosApi.post(url, { ...data\n    }, { ...config\n    }).then(response => response.data);\n  }\n\n  async put(url, data, config = {}) {\n    return axiosApi.put(url, { ...data\n    }, { ...config\n    }).then(response => response.data);\n  }\n\n  async del(url, config = {}) {\n    return await axiosApi.delete(url, { ...config\n    }).then(response => response.data);\n  } //////////////////////////////\n  //////////////////////////////\n\n  /*\r\n  fetch = function() {\r\n  let self = this;\r\n  let args = arguments;\r\n  return originalFetch.apply(self, args).then(async function(data) {\r\n  if (data.status === 200)\r\n    console.log(\"---------Status 200----------\");\r\n  if (data.status === 401) {\r\n    // request for token with original fetch if status is 401\r\n    console.log('failed');\r\n    let response = await originalFetch(TEMP_API['200'].url, TEMP_API['200'].args);\r\n    // if status is 401 from token api return empty response to close recursion\r\n    console.log(\"==========401 UnAuthorize.=============\");\r\n    console.log(response);\r\n    if (response.status === 401) {\r\n      return {};\r\n    }\r\n    // else set token\r\n    // recall old fetch\r\n    // here i used 200 because 401 or 404 old response will cause it to rerun\r\n    // return fetch(...args); <- change to this for real scenarios\r\n    // return fetch(args[0], args[1]); <- or to this for real sceaerios\r\n    return fetch(TEMP_API['200'].url, TEMP_API['200'].args);\r\n  }\r\n  // condition will be tested again after 401 condition and will be ran with old args\r\n  if (data.status === 404) {\r\n    console.log(\"==========404 Not Found.=============\");\r\n    // here i used 200 because 401 or 404 old response will cause it to rerun\r\n    // return fetch(...args); <- change to this for real scenarios\r\n    // return fetch(args[0], args[1]); <- or to this for real scenarios\r\n    return fetch(TEMP_API['200'].url, TEMP_API['200'].args);\r\n    //scenaerios\r\n  }\r\n  else {\r\n    return data;\r\n  }\r\n  });\r\n  };\r\n  */\n\n\n}","map":{"version":3,"sources":["D:/_PROJECTS/_SOAINT/JBPM/App/banescocreditoscomerciales/src/services/ApiServiceCore.js"],"names":["axios","TokenService","url","qs","http","https","userId","client_id","client_secret","httpAgent","Agent","keepAlive","httpsAgent","API_URL","axiosApi","create","baseURL","headers","interceptors","request","use","config","token","getLocalAccessToken","access_token","error","Promise","reject","response","res","err","console","log","originalConfig","URL_CORE_TOKENGEN","elapsed","Date","getTime","tokenexpiration","removeLocalAccessToken","_retry","data","stringify","grant_type","btoa","rs","post","responsetokenJson","setSeconds","getSeconds","parseInt","expires_in","updateLocalAccessToken","_error","ApiServiceCore","get","then","put","del","delete"],"mappings":"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","sourcesContent":["import axios from \"axios\"\r\nimport TokenService from \"./TokenService\";\r\nimport * as url from \"../helpers/url_helper\"\r\nimport qs from 'qs';\r\nimport http from \"http\";\r\nimport https from \"https\";\r\n\r\nconst userId = \"ARICO1\";\r\nconst client_id = '6cbk7drlvbc88vdgvgo1tg1r3o'; //'rrcmi5fefq56q4bc9pri0mfa0';//\r\nconst client_secret = 'b9vti5n8pbn1cn2gr35vlgq8s3uq7mm1j2d79ih0u1jjb4hkd3m'//'k7f89803rmgu8n93ppr3e2honuguo064ga8co4oqgml8k0tdrbp';//\r\n\r\nconst httpAgent = new http.Agent({ keepAlive: true })\r\nconst httpsAgent = new https.Agent({ keepAlive: true })\r\n\r\n    //apply base url for axios\r\n    const API_URL = \"\"\r\n\r\n    const axiosApi = axios.create({\r\n      baseURL: API_URL,\r\n      httpAgent,\r\n      httpsAgent,\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        \"userId\":userId\r\n      },\r\n    })\r\n\r\n    /*\r\n    axiosApi.interceptors.response.use(\r\n      response => response,\r\n      error => Promise.reject(error)\r\n    )\r\n    */\r\n\r\n    axiosApi.interceptors.request.use(\r\n      (config) => {\r\n        const token = TokenService.getLocalAccessToken();\r\n        if (token) {\r\n          config.headers[\"Authorization\"] = 'Bearer ' + token.access_token;\r\n          //config.headers[\"x-access-token\"] = token; // for Node.js Express back-end\r\n        }\r\n\r\n        // console.log('config: ',config);\r\n\r\n        return config;\r\n      },\r\n      (error) => {\r\n        return Promise.reject(error);\r\n      }\r\n    );\r\n\r\n\r\n    axiosApi.interceptors.response.use(\r\n      (res) => {\r\n        return res;\r\n      },\r\n      async (err) => {\r\n        //return Promise.reject(err);\r\n\r\n        console.log('err: ',err);\r\n        const originalConfig = err.config;\r\n\r\n        // console.log('originalConfig: ',originalConfig);\r\n        if(originalConfig.url === url.URL_CORE_TOKENGEN)\r\n        {\r\n          return Promise.reject(err);\r\n        }\r\n\r\n        var token = TokenService.getLocalAccessToken();\r\n\r\n        //si existe Token chequear la validez de tiempo\r\n        if(token)\r\n        {\r\n          //calculamos que el expiration time est√© correcto\r\n          var elapsed = (new Date()).getTime() - token.tokenexpiration;\r\n\r\n          if(elapsed < 0){\r\n            return Promise.reject(err);\r\n          }\r\n        }\r\n\r\n        TokenService.removeLocalAccessToken();\r\n\r\n        originalConfig._retry = true;\r\n        try {\r\n\r\n          const data = qs.stringify({grant_type: 'client_credentials'});\r\n          const headers = {\r\n            'Content-Type': 'application/x-www-form-urlencoded',\r\n            'Authorization': \"Basic \" + btoa(client_id + \":\" + client_secret)\r\n          };\r\n\r\n          var rs = await axiosApi.post(url.URL_CORE_TOKENGEN, data, {\r\n            headers: headers\r\n          });\r\n\r\n          var responsetokenJson = rs.data;\r\n\r\n          var tokenexpiration= new Date();\r\n          tokenexpiration.setSeconds(new Date().getSeconds() + parseInt(responsetokenJson.expires_in))\r\n          responsetokenJson.tokenexpiration = tokenexpiration.getTime();\r\n\r\n          TokenService.updateLocalAccessToken(responsetokenJson);\r\n\r\n          originalConfig.headers[\"Authorization\"] = 'Bearer ' + responsetokenJson.access_token;\r\n          return axiosApi(originalConfig);\r\n\r\n        }\r\n        catch (_error) {\r\n          return Promise.reject(_error);\r\n        }\r\n\r\n        /*\r\n        //originalConfig.url !== \"/auth/signin\" &&\r\n        if (err.response) {\r\n          // Access Token was expired\r\n          if (err.response.status === 401 && !originalConfig._retry) {\r\n            originalConfig._retry = true;\r\n\r\n            try {\r\n\r\n              const data = qs.stringify({\r\n                grant_type: 'client_credentials'\r\n              });\r\n              const headers = {\r\n                'Content-Type': 'application/x-www-form-urlencoded',\r\n                'Authorization': \"Basic \" + btoa(client_id + \":\" + client_secret)\r\n              };\r\n\r\n              const rs = await axiosApi.post(url_TokenGeneration,\r\n                data,headers\r\n              );\r\n\r\n              console.log(rs.data);\r\n              TokenService.updateLocalAccessToken(rs.data);\r\n\r\n              //const { accessToken } = rs.data;\r\n              return axiosApi(originalConfig);\r\n\r\n            }\r\n            catch (_error) {\r\n              return Promise.reject(_error);\r\n            }\r\n          }\r\n        }\r\n\r\n        return Promise.reject(err);\r\n\r\n        */\r\n      }\r\n    );\r\n\r\n\r\nexport default class ApiServiceCore {\r\n\r\n    async get(url, config = {}) {\r\n      return await axiosApi\r\n      .get(url, { ...config })\r\n      .then(response => response.data)\r\n    }\r\n\r\n    async post(url, data,config = {}) {\r\n      return axiosApi\r\n        .post(url, { ...data },{...config})\r\n        .then(response => response.data)\r\n    }\r\n\r\n    async put(url, data, config = {}) {\r\n      return axiosApi\r\n        .put(url, { ...data }, { ...config })\r\n        .then(response => response.data)\r\n    }\r\n\r\n    async del(url, config = {}) {\r\n      return await axiosApi\r\n        .delete(url, { ...config })\r\n        .then(response => response.data)\r\n    }\r\n\r\n    //////////////////////////////\r\n    //////////////////////////////\r\n\r\n    /*\r\n\r\nfetch = function() {\r\n  let self = this;\r\n  let args = arguments;\r\n  return originalFetch.apply(self, args).then(async function(data) {\r\n    if (data.status === 200)\r\n      console.log(\"---------Status 200----------\");\r\n    if (data.status === 401) {\r\n      // request for token with original fetch if status is 401\r\n      console.log('failed');\r\n      let response = await originalFetch(TEMP_API['200'].url, TEMP_API['200'].args);\r\n      // if status is 401 from token api return empty response to close recursion\r\n      console.log(\"==========401 UnAuthorize.=============\");\r\n      console.log(response);\r\n      if (response.status === 401) {\r\n        return {};\r\n      }\r\n      // else set token\r\n      // recall old fetch\r\n      // here i used 200 because 401 or 404 old response will cause it to rerun\r\n      // return fetch(...args); <- change to this for real scenarios\r\n      // return fetch(args[0], args[1]); <- or to this for real sceaerios\r\n      return fetch(TEMP_API['200'].url, TEMP_API['200'].args);\r\n    }\r\n    // condition will be tested again after 401 condition and will be ran with old args\r\n    if (data.status === 404) {\r\n      console.log(\"==========404 Not Found.=============\");\r\n      // here i used 200 because 401 or 404 old response will cause it to rerun\r\n      // return fetch(...args); <- change to this for real scenarios\r\n      // return fetch(args[0], args[1]); <- or to this for real scenarios\r\n      return fetch(TEMP_API['200'].url, TEMP_API['200'].args);\r\n      //scenaerios\r\n    }\r\n    else {\r\n      return data;\r\n    }\r\n  });\r\n};\r\n*/\r\n\r\n}\r\n\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}